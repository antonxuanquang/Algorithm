
public class Four {
	/*
	 * 
	 * Sorted Search, No Size: you are given an array-like data structure Listy
	 * which lacks a size method. It does, however, have an elementAt(i) method 
	 * that returns the element at index i in O(1) time. If i is beyond the bounds 
	 * of the data structures, it returns -1. (For this reason, the data structure
	 * only supports positive integers). Given a Listy which contains sorted, positive
	 * integers, find the index at which an element x occurs. If x occurs multiple times,
	 * you may return any index.
	 * 
	 */
	
	public static <T extends Comparable<T>> int noSizeSearch(T[] array, T item) {
		
		int power = findNearestPower(array);
		int index = (int) Math.pow(2, power) - 1;
		power--;
		while (power >= 0) {
			System.out.println("index: " + index);
			if (index > array.length) {
				index -= (int) Math.pow(2, power);
				continue;
			}
			if (array[index].compareTo(item) == 0) return index;
			else if (index > array.length 
					|| array[index].compareTo(item) < 0) 
				index -= (int) Math.pow(2, power);
			else if (array[index].compareTo(item) > 0)
				index += (int) Math.pow(2, power);
			power--;
		}
		return -1;
	}
	
	private static <T extends Comparable<T>> int findNearestPower(T[] array) {
		int power = 0;
		while (Math.pow(2, power) < array.length) power++;
		return power - 1;
	}
	
	public static void main(String[] args) {
		Integer[] array = {1,3,4,6,7,8,9,22,53,74,172};
		System.out.println(array.length);
		System.out.println(noSizeSearch(array, 3));
	}
}
