import org.omg.CORBA.Current;


public class Twelve {
	/*
	 * 
	 * Paths wit Sum: you are given a binary tree in which each node contains 
	 * an integer value (which might be positive or negative). Design an 
	 * algorithm to count the number of paths that sum to a given value.
	 * The path does not need to start or end at the root or a leaf, but it
	 * must go downwards (traveling only from parent nodes to child nodes) 
	 * 
	 */
	
	public static int pathWithSum(BTNode<Integer> node, int number) {
		int sum = 0;
		int path = pathWithSum(node, sum, number);
		return path;
	}

	private static int pathWithSum(BTNode<Integer> node, int sum, int number) {
		if (node == null) return 0;
		if (sum == number) return 1 
				+ pathWithSum(node.getLeft(), node.getData(), number) 
				+ pathWithSum(node.getRight(), node.getData(), number);
		return pathWithSum(node.getLeft(), sum + node.getData(), number) 
				+ pathWithSum(node.getRight(), sum + node.getData(), number);
		
	}
	
	public static void main(String[] args) {
		BTNode<Integer> a = new BTNode<Integer>("a");
		BTNode<Integer> b = new BTNode<Integer>("b");
		BTNode<Integer> c = new BTNode<Integer>("c");
		BTNode<Integer> d = new BTNode<Integer>("d");
		BTNode<Integer> e = new BTNode<Integer>("e");
		BTNode<Integer> f = new BTNode<Integer>("f");
		BTNode<Integer> g = new BTNode<Integer>("g");
		BTNode<Integer> h = new BTNode<Integer>("h");

		// false case
//		a.setLeft(b);
//		a.setRight(h);
//		b.setLeft(c);
//		b.setRight(d);
////		c.setRight(h);
//		h.setLeft(e);
//		h.setRight(g);
//		e.setLeft(f);
//		System.out.println(isBST(a));
		
		// true case
		d.setLeft(b);
		b.setLeft(a);
		b.setRight(c);
		
		d.setRight(f);
		f.setLeft(e);
		f.setRight(g);
		
		g.setRight(h);
//		g.setLeft(h);
		
		
		System.out.println(isBST(d));
		System.out.println(isBST2(d));
		System.out.println(isBST3(d));
	}
}
