import java.util.EmptyStackException;

public class MultiStack {
	

/*
 * 
 * This is the first approach, haven't finish yet. It was too complicated
 * I will implement a simpler verion of stack, without 
 * 
	// the index of head
	private int alpha = -1;
	private int beta = -1;
	private int gamma = -1;

	// this keep track of how many slot has been used
	private int usedSlot = 0;

	// this keep track of previous slot has just used
	private int previouSlot;

	// this array stores all three smaller stacks inside
	private ThreeInOneStackNode [] stack = new ThreeInOneStackNode[1];

	private class ThreeInOneStackNode {
		private int data;
		private int next;

		public ThreeInOneStackNode(int data) {
			this.data = data;
			next = -1;
		}
	}

	private void resize(int max) {
		ThreeInOneStackNode[] temp = new ThreeInOneStackNode[max];
		int alphaRunner = alpha;
		int counter = 0;
		while (stack[alphaRunner] != null) {
			temp[counter] = stack[alphaRunner];
			temp[counter].next = counter++; 
			alphaRunner = stack[alphaRunner].next;
		}
		stack = temp;
	}

	private int nextAvailable() {
		for (int i = 0; i < stack.length; i++) {
			// this helps to make a wrap around index
			int slot = (i + previouSlot) % stack.length;
			if (stack[slot] == null) {
				// update previousSlot
				previouSlot = slot;
				return slot;
			}
		}
		return -1;
	}

	public int alphaPop() {
		// when the stack is empty
		if (alpha == -1) throw new EmptyStackException();

		// data to return
		int item = stack[alpha].data;

		// save the index of next item
		int next = stack[alpha].next;

		// delete the top item
		stack[alpha] = null;

		// change top item index
		alpha = next;

		// decrement usedSlot
		usedSlot--;

		// resize the stack if needed
		if (usedSlot > 0 && usedSlot == stack.length / 4)
			resize(stack.length / 2);

		return item;

	}

	public void alphaPush(int item) {

		// find next available slot
		int nextTop = nextAvailable();
		if (nextTop == -1) {
			System.out.println("something went wrong in getting stack next index");
			return;
		}

		// create new item
		ThreeInOneStackNode node = new ThreeInOneStackNode(item);

		// change the top
		node.next = alpha;
		alpha = nextTop;
		stack[nextTop] = node;

		// increment usedSlot
		usedSlot++;
		// resize the stack if full
		if (usedSlot == stack.length)
			resize(2 * stack.length);
	}

	public int alphaPeek() {
		return stack[alpha].data;
	}

	public boolean isAlphaEmpty() {
		return stack[alpha] == null;
	}

	public String toString() {
		StringBuilder result = new StringBuilder();
		int alphaRunner = alpha;
		result.append(stack[alphaRunner].data);
		while (stack[alphaRunner] != null) {
			result.append(" -> " + stack[alphaRunner].data);
			alphaRunner = stack[alphaRunner].next;
		}
		return result.toString();
	}
*/
	
	private int [] stackInfo;
	// this array stores all three smaller stacks inside
	private ThreeInOneStackNode[] stackNodes;
	
	private class ThreeInOneStackNode {
		private int data;
		private int next;

		public ThreeInOneStackNode(int data) {
			this.data = data;
			next = -1;
		}
	}
	
	public MultiStack (int numberOfStack, int sizeOfStack) {
		stackInfo = new int [numberOfStack];
		stack = new ThreeInOneStackNode[sizeOfStack];
	}
	
	private int nextAvailable() {
		for (int i = 0; i < stack.length; i++) {
			// this helps to make a wrap around index
			int slot = (i + previouSlot) % stack.length;
			if (stack[slot] == null) {
				// update previousSlot
				previouSlot = slot;
				return slot;
			}
		}
		return -1;
	}
	
	
	
}
