import java.util.HashMap;


public class Fourteen {
	
	/*
	 * 
	 * Boolean Evaluation: Given a boolean expression consisting of the symbols
	 * 0 (false), 1 (true), & (AND), | (OR), and ^ (XOR), and a desired boolean
	 * result value result, implement a function to count the number of ways of
	 * parenthesizing the expression such that it evaluates to result. The 
	 * expression should be fully parenthesized (e.g., (0)^(1)) but not 
	 * extraneously (e.g., (((0))^(1))))
	 * 
	 * Example: 
	 * countEval("1^0|0|1", false) -> 2
	 * countEval("0&0&0&1^1", true) -> 10
	 * 
	 */
	
	
	public static int countEval(String s, boolean result, HashMap<String, Integer> memmo) {
		if (s.length() == 0) return 0;
		if (s.length() == 1) return result ? 1 : 0;
		
		int ways = 0;
		
		for (int i = 1; i < s.length(); i += 2) {
			char c = s.charAt(i);
			String leftSub = s.substring(0, i);
			String rightSub = s.substring(i + 1, s.length());
			
			int leftFalse = countEval(leftSub, false, memmo);
			int leftTrue = countEval(rightSub, true, memmo);
			int rightFalse = countEval(rightSub, false, memmo);
			int rightTrue = countEval(rightSub, true, memmo);
			
			int total = (leftFalse + leftTrue) * (rightFalse + rightTrue);
			
			int totalTrue = 0;
			switch (c) {
			case '&': totalTrue = leftTrue * rightTrue; break;
			case '|': totalTrue = (leftFalse * rightTrue) 
								+ (leftTrue * rightTrue)
								+ (leftTrue * rightTrue); break;
			case '^': totalTrue = (leftFalse * rightTrue)
								+ (leftTrue * rightFalse); break;
			}
		}
		
		memmo.put(result + s, ways);		
		return ways;
	}
}
