import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.Stack;


public class Three {
	/*
	 * 
	 * Implement a SetOfStacks should be composed of serveral stacks
	 * and should create a new stack once the previous one exceeds 
	 * capacity. SetOfStacks.push() and SetOfStacks.pop() should 
	 * behave identically to a single stack (that is, pop() should 
	 * return the same values as it would if there were just a single
	 * stack). 
	 * 
	 */
	
	private static class StackWithCapacity extends Stack<Integer>{
		int capacity = 0;
		
		public void increment() {
			capacity++;
		}
		
		public void decrement() {
			capacity--;
		}
	}
	
	private static class SetOfStacks {
		ArrayList<StackWithCapacity> stackList;
		private final int CAPACITY;
		
		public SetOfStacks(int capacity) {
			this.CAPACITY = capacity;
			stackList = new ArrayList<StackWithCapacity>();
		}
		
		public void push(int value) {
			int currentStack = 0;
			// get the nearest un-full stack
			while (stackCapacity(currentStack) == CAPACITY) {
				currentStack++;
			}
			
			StackWithCapacity stack = stackList.get(currentStack);
			
			// if stack has not been initialize
			if (stack == null) stack = new StackWithCapacity();
			
			stack.push(value);
			
			// increment volume of a stack
			stackList.get(currentStack).capacity++;
		}
		
		public int pop() {
			if (stackList.get(0) == null) throw new NoSuchElementException();
			StackWithCapacity stack = stackList.get(stackList.size() - 1);
			stack.capacity--;
			return stack.pop();
		}
		
		public int popAt(int stackNumber) {
			if (stackNumber >= stackList.size()) throw new IndexOutOfBoundsException();
			StackWithCapacity stack = stackList.get(stackNumber);
			stack.capacity--;
			return stack.pop();
		}
		
		private int stackCapacity(int stackNumber) {
			return stackList.get(stackNumber).capacity;
		}
		
	}
}
