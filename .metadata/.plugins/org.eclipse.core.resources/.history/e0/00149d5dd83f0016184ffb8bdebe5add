
public class Ten {
	/*
	 * 
	 * Check Subtree: T1 and T2 are two very large binary trees, with T1 much bigger than T2.
	 * Create an algorithm to determine if T2 is a subtree of T1.
	 * 
	 * A tree T2 is a subtree of T1 if there exists a node n in T1 such that the subtree of 
	 * n is identical to T2. That is, if you cut off the tree at node n, the two trees would
	 * be identical 
	 * 
	 */
	
	private static class Result {
		boolean found;
		boolean isIdentity;
		
		public Result(boolean found, boolean isIdentity) {
			this.found = found;
			this.isIdentity = isIdentity;
		}
	}
	
	public static boolean checkSubtree(BinaryTreeNode root, BinaryTreeNode node) {
		Result result = checkSubtreeHelper(root, node);
		return result.isIdentity;
		
	}
	
	private static Result checkSubtreeHelper(BinaryTreeNode root, BinaryTreeNode node) {
		if (root == null) return new Result(false, false);
		if (root.getLabel() == node.getLabel()) return new Result(true, isIdentity(root, node));
		Result left = checkSubtreeHelper(root.getLeft(), node);
		Result right = checkSubtreeHelper(root.getRight(), node);
		return new Result(left.found || right.found, left.isIdentity && right.isIdentity);
	}
	
	private static boolean isIdentity(BinaryTreeNode root, BinaryTreeNode node) {
		if (root == null && node == null) return true;
		if (root.getLabel() != node.getLabel()) return false;
		boolean left = isIdentity(root.getLeft(), node.getLeft());
		boolean right = isIdentity(root.getRight(), node.getRight());
		return left && right;
	}
}
